#!/usr/bin/env python3

import argparse
import os
import subprocess
import sys

try:
    from dotenv import load_dotenv
except ModuleNotFoundError:
    raise SystemExit(
        "Missing dependency: python-dotenv. Install it with 'sudo apt-get install python3-dotenv' or 'pip install python-dotenv'."
    )
from pathlib import Path


def sync(repo_name, branch, show=False):
    path = str(Path(__file__).resolve().parent)
    src_path = path + "/src/"
    repo_path = src_path + "custom/" + repo_name
    if not os.path.isdir(repo_path):
        print("No se encuentra el repositorio solicitado!")
        return
    os.chdir(repo_path)

    stdout = subprocess.DEVNULL
    stderr = subprocess.STDOUT

    if show:
        stdout = None
        stderr = None
    print("\r %s: Guardando cambios actuales... " % (repo_name), end=" " * 50)
    value = subprocess.run(["git", "status"], capture_output=True)
    values_lines = value.stdout.decode().split("\n")
    branch_now = values_lines[0].replace("On branch ", "")

    submodules = ["integra-addons", "third-party-addons", "odoo-venezuela"]
    # Mapping from submodule names to their corresponding internal Git module directory names.
    # This is necessary when the submodule's directory name in .gitmodules differs from the name used in the codebase.
    # For example, "odoo-venezuela" is referred to as "homo-addons" in the .gitmodules file.
    submodule_gitmodules_map = {"odoo-venezuela": "homo-addons"}
    print(
        "\r %s: Cambiando a %s                           " % (repo_name, branch),
        end=" " * 50,
    )
    subprocess.run(["git", "stash"], stdout=stdout, stderr=stderr)
    subprocess.run(["git", "checkout", branch], stdout=stdout, stderr=stderr)
    subprocess.run(["git", "pull"], stdout=stdout, stderr=stderr)
    print(
        "\r %s: Actualizando %s                          " % (repo_name, branch),
        end=" " * 50,
    )
    for submodule in submodules:
        subprocess.run(
            ["git", "reset", "HEAD", "--", submodule], stdout=stdout, stderr=stderr
        )
        subprocess.run(
            ["git", "-C", submodule, "stash", "--include-untracked"],
            stdout=stdout,
            stderr=stderr,
        )
        subprocess.run(
            ["git", "submodule", "update", "--init", "--force", "--", submodule],
            stdout=stdout,
            stderr=stderr,
        )
        print(
            "\r %s: Obteniendo submodulos de %s                     "
            % (repo_name, branch),
            end=" " * 50,
        )

    print("")
    for submodule in submodules:
        if not show:
            print("\r %s Sincronizando... " % (submodule), end="")
        commit = ""
        submodule_internal = submodule_gitmodules_map.get(submodule, submodule)
        try:
            with open(
                repo_path + "/.git/modules/" + submodule_internal + "/HEAD", "r"
            ) as Modules:
                line = Modules.readlines()[0]
                if line.startswith("ref:"):
                    commit = line.split("/")[2].replace("\n", "")
                else:
                    commit = line.replace("\n", "")

            if not commit:
                continue
            submodule_path = src_path + submodule
            os.chdir(submodule_path)
            subprocess.run(["git", "stash"], stdout=stdout, stderr=stderr)
            subprocess.run(["git", "fetch"], stdout=stdout, stderr=stderr)
            response = subprocess.run(["git", "checkout", commit], capture_output=True)
            success = response.stderr.decode()

            if commit[:8] not in success and commit[:7] not in success:
                print(commit.encode())
                print(success.encode())
                print("ERROR")
                raise Exception("Error")

            if not show:
                print(
                    "\r %s ( %s ) Sincronizado ‚úÖ" % (submodule, commit), end=" " * 30
                )
        except Exception as a:
            print(a)
            if not show:
                print(
                    "\r %s ( %s ) Sincronizado Fallido ‚ùå" % (submodule, commit),
                    end=" " * 30,
                )

        if not show:
            print("")

    os.chdir(repo_path)
    subprocess.run(["git", "checkout", branch_now], stdout=stdout, stderr=stderr)
    subprocess.run(["git", "stash", "pop"], stdout=stdout, stderr=stderr)


def run_bash():
    PROJECT_NAME = os.getenv("PROJECT_NAME")
    print(f"docker exec -u root -it {PROJECT_NAME} bash")
    os.system(f"docker exec -u root -it {PROJECT_NAME} bash")


def bash_update_modules(dbname: str, modules: str = "all"):
    PROJECT_NAME = os.getenv("PROJECT_NAME")
    print(
        f"docker exec -u root -it {PROJECT_NAME} odoo --stop-after-init -p 90 --workers=0 -u {modules} -d {dbname}"
    )
    os.system(
        f"docker exec -u root -it {PROJECT_NAME} odoo --stop-after-init -p 90 --workers=0 -u {modules} -d {dbname}"
    )


def build_odoo(no_cache):
    ODOO_VERSION = os.getenv("ODOO_VERSION")
    RESOURCES_DIR = "/.resources"
    file_path = str(Path(__file__).resolve().parent)

    if not os.path.exists(file_path + "/.env"):
        print("Error #1: The file .env does not exist")
        return

    if not ODOO_VERSION:
        print("Error #2: ODOO_VERSION is not defined")
        return

    try:
        with open(file_path + RESOURCES_DIR + "/Dockerfile", "w") as Dockerfile:
            dockerfile_path = (
                file_path
                + RESOURCES_DIR
                + "/dockerfiles/"
                + ODOO_VERSION
                + "_Dockerfile"
            )
            dockerfile_template_path = (
                file_path + RESOURCES_DIR + "/Dockerfile.template"
            )

            if not os.path.exists(dockerfile_path):
                raise BaseException(
                    f"Error #3: Dockerfile for {ODOO_VERSION} does not exist"
                )

            if not os.path.exists(dockerfile_template_path):
                raise BaseException("Error #3: Dockerfile.template does not exist")

            with open(dockerfile_path, "r") as dockerfile_version:
                Dockerfile.write(dockerfile_version.read())
                Dockerfile.write(
                    "\n"
                )  # Opcional: agregar un salto de l√≠nea entre los archivos

            with open(dockerfile_template_path, "r") as dockerfile_template:
                Dockerfile.write(dockerfile_template.read())
                Dockerfile.write(
                    "\n"
                )  # Opcional: agregar un salto de l√≠nea entre los archivos

    except FileNotFoundError as e:
        print(e)
    if no_cache:
        print("Construyendo Odoo sin cach√©...")
        os.system("docker compose -f docker-compose.app.yml build --no-cache")
    else:
        print("Construyendo Odoo con cach√©...")
        os.system("docker compose -f docker-compose.app.yml build")


def init_addons():
    ORG_NAME = os.getenv("ORG_NAME") or "binaural-dev"
    required_sources = {
        "binaural": [
            f"{ORG_NAME}/enterprise",
            f"{ORG_NAME}/integra-addons",
            f"{ORG_NAME}/third-party-addons",
            f"{ORG_NAME}/odoo-venezuela",
        ],
        "external": [f"{ORG_NAME}/odoo-venezuela"],
        "enterprise": [f"{ORG_NAME}/enterprise"],
    }
    ENV_TYPE = os.getenv("ENV_TYPE")
    print("Clonando Repositorios")
    ODOO_VERSION = os.getenv("ODOO_VERSION")
    SOURCES = os.path.join(Path(__file__).resolve().parent, "src")

    for repository in required_sources[ENV_TYPE]:
        name = repository.split("/")[1]
        path = os.path.join(SOURCES, name)
        if not os.path.isdir(os.path.join(SOURCES, name)):
            os.system(
                f"git clone -b '{ODOO_VERSION}' git@github.com:{repository}.git {path}"
            )
        else:
            print(f"{repository} exists")


def start_odoo():
    print("\n=== Iniciando Odoo ===\n")

    # Levantar base de datos
    print("‚Üí Iniciando base de datos...")
    cmd_db = "docker compose -f docker-compose.db.yml up -d"
    print(cmd_db)
    os.system(cmd_db)

    # Levantar aplicaci√≥n Odoo
    print("\n‚Üí Iniciando aplicaci√≥n Odoo...")
    cmd_app = "docker compose -f docker-compose.app.yml up -d"
    print(cmd_app)
    os.system(cmd_app)

    print("\n‚úÖ Odoo y base de datos est√°n en ejecuci√≥n.\n")


def stop_odoo():
    print("\n=== Deteniendo Odoo ===\n")

    # Detener aplicaci√≥n Odoo
    print("‚Üí Deteniendo aplicaci√≥n Odoo...")
    cmd_app = "docker compose -f docker-compose.app.yml down"
    print(cmd_app)
    os.system(cmd_app)

    # Detener base de datos
    print("\n‚Üí Deteniendo base de datos...")
    cmd_db = "docker compose -f docker-compose.db.yml down"
    print(cmd_db)
    os.system(cmd_db)

    print("\nüõë Odoo y base de datos han sido detenidos.\n")


def remove_odoo():
    print("\n=== Eliminando Odoo ===\n")

    do_continue = input(
        "‚ö†Ô∏è  Esto eliminar√° todos los datos de Odoo y la base de datos. ¬øDeseas continuar? (s/n):  "
    )

    if do_continue.lower() == "s":
        print("Continuando con la eliminaci√≥n...")
    else:
        print("Operaci√≥n cancelada.")
        sys.exit()
        return

    # Detener aplicaci√≥n Odoo
    print("‚Üí Eliminando aplicaci√≥n Odoo...")
    cmd_app = "docker compose -f docker-compose.app.yml down -v --remove-orphans"
    print(cmd_app)
    os.system(cmd_app)

    # Detener base de datos
    print("\n‚Üí Eliminando base de datos...")
    cmd_db = "docker compose -f docker-compose.db.yml down -v --remove-orphans"
    print(cmd_db)
    os.system(cmd_db)

    print("\nüõë Odoo y base de datos han sido eliminados.\n")


def restart_odoo():
    print("\n=== Reiniciando Odoo ===\n")

    # Detener aplicaci√≥n Odoo
    stop_odoo()

    # Iniciar aplicaci√≥n Odoo
    start_odoo()

    print("\n‚úÖ Odoo y base de datos reiniciados correctamente.\n")


def list_containers():
    cmd = "docker compose -f docker-compose.app.yml ps"
    os.system(cmd)


def show_logs():
    cmd_db = "docker compose -f docker-compose.db.yml logs --tail=10 -f"
    cmd_app = "docker compose -f docker-compose.app.yml logs --tail=10 -f"

    # Abrir dos terminales independientes
    os.system(cmd_app)
    os.system(cmd_db)


def psql(d):
    print(d)
    PROJECT_NAME = os.getenv("PROJECT_NAME")
    POSTGRES_USER = os.getenv("POSTGRES_USER")
    POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD")
    os.system(
        f"docker exec -it -e PGPASSWORD={POSTGRES_PASSWORD} {PROJECT_NAME} psql --host {PROJECT_NAME}_db -U {POSTGRES_USER} -d {d}"
    )


def main():
    # Cargar las variables de entorno
    load_dotenv()

    # Crear el parser
    parser = argparse.ArgumentParser(description="Script para controlar Odoo.")

    subparsers = parser.add_subparsers(dest="action", help="Acciones")
    subparsers.add_parser("start", help="Ejecuta Odoo")
    subparsers.add_parser("stop", help="Detiene Odoo")
    subparsers.add_parser("restart", help="Reiniciar Odoo")
    subparsers.add_parser("bash", help="Bash")
    subparsers.add_parser("init", help="Clone repositories")

    # Subparser para el comando "logs"
    subparsers.add_parser("logs", help="Muestra los √∫ltimos 10 logs en tiempo real")

    subparsers.add_parser("list", help="Lista los contenedores en ejecuci√≥n")

    subparsers.add_parser("remove", help="Lista los contenedores en ejecuci√≥n")

    # Subparser para el comando "build"
    build_parser = subparsers.add_parser("build", help="Construye Odoo")
    build_parser.add_argument(
        "--no-cache", action="store_true", help="Construir sin usar cach√©"
    )

    psql_parser = subparsers.add_parser("psql", help="psql")
    psql_parser.add_argument("-d", required=True, help="Database name")

    sync_parser = subparsers.add_parser("sync", help="Sync Submodules")
    sync_parser.add_argument("r", help="Repository")
    sync_parser.add_argument("b", help="Branch")
    sync_parser.add_argument("--v", action="store_true", default=False, help="Git log")

    update_parser = subparsers.add_parser("update", help="Update Modules")
    update_parser.add_argument("-d", required=True, help="Database name")
    update_parser.add_argument(
        "-m",
        default="all",
        help="Modules to update, default all. Use comma to separate multiple modules",
    )

    # Parsear los argumentos
    args = parser.parse_args()

    # Ejecutar la acci√≥n correspondiente
    if args.action == "start":
        start_odoo()
        return True
    if args.action == "stop":
        stop_odoo()
        return True
    if args.action == "restart":
        restart_odoo()
        return True
    if args.action == "build":
        build_odoo(args.no_cache)
        return True

    if args.action == "bash":
        run_bash()
        return True

    if args.action == "update":
        bash_update_modules(args.d, args.m)
        return True

    if args.action == "init":
        init_addons()
        return True

    if args.action == "psql":
        psql(args.d)
        return True

    if args.action == "sync":
        sync(args.r, args.b, show=args.v)
        return True

    if args.action == "logs":
        show_logs()
        return True

    if args.action == "list":
        list_containers()
        return True

    if args.action == "remove":
        remove_odoo()
        return True

    parser.print_help()

    return False


if __name__ == "__main__":
    main()
